# 第8章 基于Reactor模式的系统优化

## 1 Netty

- 概述：Netty是一个异步事件驱动的网络应用框架
- 特点：
    1. 设计优雅，适用于各种传输类型的统一API阻塞和非阻塞Socket
    2. 基于灵活且扩展的事件模型，清晰地分离关注点
    3. 高度可定制的线程模型，支持一个或多个线程池
    4. 支持无连接数据包Socket
    5. 使用方便
    6. 高性能、高吞吐量、低延迟
    7. 安全、完整的SSL/TLS和STARTTLS支持
    8. 社区活跃，版本迭代周期短
    
- BIO：使用多线程方式，反复调用accept方法，直到收到连接请求，建立通信Socket，需要为每一个客户端的连接请求创建一个线程来单独处理
- BIO的不足：
    1. 每个请求都需要独立的线程来完成数据读写的整个操作
    2. 当并发量较大时，需要创建大量的线程处理连接，造成资源占用过多
    3. 建立连接后，当前线程如果没有数据可读，将阻塞读操作，导致线程资源浪费
    
- NIO：使用多路复用器，开启一个线程处理来自多个客户端的IO事件

## 2 Reactor编程模型

- Reactor机制：应用程序提供相应的接口注册到Reactor上，如果相应的事件发生，将主动调用已注册的接口，这些接口称为回调函数
- 事件驱动模型：发生事件后，主线程把事件放入队列中，其他线程不断循环消费队列中的事件，调用事件对应的处理逻辑来处理事件
- 事件驱动模型的优点：
    1. 分布式的异步架构，可扩展性好
    2. 高性能，基于队列暂存事件，支持并行异步处理事件
- 事件驱动设计的基本组件
    1. 事件队列：接收事件的入口，存储待处理事件
    2. 事件分发器：将不同的事件分发到不同的业务逻辑单元
    3. 事件通道：分发器与事件处理器之间的沟通渠道
    4. 事件处理器：实现业务逻辑，处理完成后，触发下一步操作
- Reactor编程模型：
    1. 由BossGroup负责新客户端的连接操作，建立Channel通道
    2. 将一定事件内的Channel注册到另一个WorkerGroup
    3. 由WorkerGroup将客户端的读写请求交给线程池WorkerThread处理
    4. WorkerThread基于PipeLine快速处理请求
    
## 3 设计思路

- 对于原生阻塞：利用操作系统的NIO/AIO、基于底层提供的API，使用少量线程处理大量的阻塞
- 对于远程系统调用：使用NIO机制，协同上有系统，通过异步化以及批量获取结果
- 对于无法异步协同的阻塞操作：独立部署一个阻塞请求网关代理，并加大线程池数量